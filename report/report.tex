\documentclass[a4paper]{article}
\usepackage{fullpage}

\usepackage[paper=a4paper]{geometry}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{courier}
\lstloadlanguages{Java}
\lstset{
  basicstyle=\footnotesize\ttfamily,
  numberstyle=\tiny,         
  numbersep=5pt,             
  tabsize=2,                 
  extendedchars=true,        
  breaklines=true,           
  keywordstyle=\color{red},
  frame=b,         
  stringstyle=\color{white}\ttfamily,
  showspaces=false,           
  showtabs=false,             
  xleftmargin=17pt,
  framexleftmargin=17pt,
  framexrightmargin=5pt,
  framexbottommargin=4pt,
  showstringspaces=false,
  numbers=left,
}

\begin{document}

\title{The Glorious MAlice Compiler}

\author{\emph{legi, collegi, exsequi}\\ \\Francesco Mazzoli - fm2209\\Maximilian Staudt - ms9109}

\maketitle

We chose to write our compiler in Haskell, targeting the Intel 386
architecture. We tried to keep the code as clean and concise as
possible, and as a result the line count is just below 2000 lines.\\
This section is an overview to what the compiler does and how.

We had to define our own specification, following the examples
provided. In deciding what is valid and what is not we tried to
be reasonable while following the idea of an English language-like
code.

This is probably the coursework on which we spent more time on so far,
and we had to make a lot of decisions on various fields, but overall
it was a very rewarding experience.

\section{Haskell}
We chose Haskell for this project. We love Haskell, and after rapidly
looking at the available libraries we thought that it was a sane
choice. It turned out to be a great decision, especially after
discovering Parsec.

Parsec is a monadic parser combinator library for Haskell. Writing a
parser in Parsec eliminates the need of having a lexer that processes
the text, and has the huge advantage of writing the
parser without the need to use files with a different syntax (as is done
when using lex+yacc) and regular expressions.\\ While this
is the biggest advantage in our opinion, there is a lot more to
Parsec, for example error reporting.

The code makes extensive use of monads. Parsec is monadic, the type
checker makes use of the Error monad combinator with the state as the
inner monad, and the IR and Code generators both use a state monad.

\section{Code structure}

\subsection{Parser and Type Checker}
The base of the code is the \textbf{\texttt{AST} (Abstract Syntax
Tree)} data type. This data type is generated by the parser and
present in the compiling process
up to the IR generation. The \texttt{AST} contains the name of the
file and a list of function declarations, each with the function name,
its parameters and its body of commands. To simplify the
\texttt{AST}, the unbound code that does not belong to any function
in an .alice file is stored in a special function named
\texttt{\_main} that will be executed automatically.\\
There are a total of 10 possible statements: Variable declarations,
variable assignments, user input, user output, increments, decrements,
function calls, returns, conditionals and loops.\\
A rigid type checker ensures that only valid statements are passed to the further
LL and Code Generation steps.

Values of any type are represented by the data type
\textbf{\texttt{Expr}} and can contain any mathematically senseful
combination of mathematical
operations (e.g. addition, subtraction, multiplication, division, modulo...),
other variables' values and function call return values.


\subsection{LL Code: The intermediate representation}

We chose to generate an intermediate representation of the code in form
of a Haskell data structure. The "low level" \emph{LL code} contains only
fairly atomic commands that resemble assembly instructions as well as a
few helper structures to facilitate code generation.\\
The LL code is built recursively from the list of statements, with each
statement being replaced by a well-known working piece of code for it.
Whenever an expression has to be evaluated in order for the statement to
execute, the code for this is generated beforehand and inserted just
before or within the statement's code.\\
As an exercise and to create an easily verifiable code base
we stuck with generating code that resembles a "stack machine",
using only registers eax and ebx of the Intel 386 processor. But the LL layer
is in fact designed to be easily expandable so an LLVM-like code generation
module with graph colouring for an unlimited amount of virtual "LL registers"
can be used afterwards. It can also easily be expanded for new commands,
thanks to Haskell's flexible pattern matching abilities.


\subsection{Code Generation}

Since right now the LL code resembles Intel 386 code already fairly closely,
code generation for the \emph{nasm} assembler used is fairly straightforward
and mostly a 1:1 replacement of haskell data structures with assembly code strings.
In the future, several steps could be inserted between LL and Code Generation:
An optimiser that works on the LL representation and a "flattener" that
translates LL code with possibly too many flexibility into more limited
assembly.


\subsection{Compilation}

Finally, the compilation process is driven by a bash script that complements
the extensive error checking and reporting already in place within the compiler.
It compiles the complimentary \emph{libmalice} and links them together.


\subsection{libmalice: The MAlice continues on assembly level}



\end{document}

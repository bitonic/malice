We chose to implement the Alice compiler in haskell.
The compiler consists of 4 parts:
- The Parser:
  The lexer/parser is written with the aid of the parsec library
  ( http://research.microsoft.com/en-us/um/people/daan/parsec.html ).
  Parsec is a monadic parser that does not separate the grammar for the language
  from the actual programming language you are writing the compiler with, like
  most bottom-up parser generators (yacc and derivatives) do.
  This gives you all the advantages of a wonderful language such as haskell while
  writing your parser and lets you forget about regular expressions.
  For more information: http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.html
- The semantics checker:
  Once the AST is produced, the compiler checks the semantics and builds the
  symbol table in one go. To do that, the Error monad transformer was used, with a State monad
  as the inner monad. The Error monad is used to throw errors if problems are encountered,
  short-circuiting the monad. The State monad inside it "brings around" the symbol table and the
  current position in the file.
- The IR generator
  Once the code is parsed, it is broken down into rather atomic commands,
  the intermediate representation. In our compiler this is the LL (low-level)
  prefixed code. It currently resembles x86 assembly in Intel style assembly
  quite closely but will be further generalised in the future, allowing code
  generation for various platforms as well as a broad range of optimisations.
  The IR is of particular interest for LLVM targets: It is designed to be
  translated to SSA easily.
- The code generator
  This is currently a backend that generates primitive assembly code for
  x86-32 processors. After generalising the IR as mentioned above this will
  be easily exchangeable for code generators for other architectures.
